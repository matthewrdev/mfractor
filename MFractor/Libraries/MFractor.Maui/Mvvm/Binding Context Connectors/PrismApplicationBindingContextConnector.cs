using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.Linq;
using MFractor.Code.Formatting;
using MFractor.Code.WorkUnits;
using MFractor.CodeSnippets;
using MFractor.Configuration.Attributes;
using MFractor.Utilities;
using MFractor.Work;
using MFractor.Workspace;
using MFractor.Workspace.WorkUnits;
using MFractor.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.FindSymbols;

namespace MFractor.Maui.Mvvm.BindingContextConnectors
{
    class PrismApplicationBindingContextConnector : BindingContextConnector
    {
        public override string Identifier => "com.mfractor.binding_context_connector.prism_application";

        public override string Name => "(Prism) Register Within Application.RegisterTypes";

        public override string Documentation => "When Prism is being used, locates the application implementation and injects that page and viewmodel assocation into the registery provided into the RegisterTypes method.";

        const string viewModelTypeArgument = "viewModelType";
        const string viewTypeArgument = "viewType";
        const string containerRegistryNameArgument = "containerRegistryName";

        [CodeSnippetArgument(viewModelTypeArgument, "The fully qualified metatype of the ViewModel.")]
        [CodeSnippetArgument(viewTypeArgument, "The fully qualified metatype of the View.")]
        [CodeSnippetArgument(containerRegistryNameArgument, "The name of the IContainerRegistry for the View.")]
        [ExportProperty("The code snippet that gets the ViewModel from the View.")]
        [CodeSnippetDefaultValue("$containerRegistryName$.RegisterForNavigation<$viewType$, $viewModelType$>();", "Registers a new view and view model for navigation in the IContainerRegistry.")]
        public ICodeSnippet ViewModelPropertySnippet
        {
            get; set;
        }

        [ImportingConstructor]
        public PrismApplicationBindingContextConnector(Lazy<ICodeFormattingPolicyService> formattingPolicyService,
                                               Lazy<IXmlFormattingPolicyService> xmlFormattingPolicyService,
                                                       Lazy<IProjectService> projectService)
            : base(formattingPolicyService, xmlFormattingPolicyService, projectService)
        {
        }

        public override IReadOnlyList<IWorkUnit> Connect(CreateProjectFileWorkUnit view,
                                                       CreateProjectFileWorkUnit codeBehind,
                                                       CreateProjectFileWorkUnit viewModel,
                                                       string viewModelMetaType, string viewMetaType, ProjectIdentifier projectIdentifier)
        {
            var implementations = GetImplementationsOfPrismApplication(projectIdentifier);
            var project = ProjectService.GetProject(projectIdentifier);

            var workUnits = new List<IWorkUnit>()
            {
                view, codeBehind, viewModel
            };

            foreach (var impl in implementations)
            {
                var insertions = CreateInsertions(project, impl, viewModelMetaType, viewMetaType);

                if (insertions != null && insertions.Any())
                {
                    workUnits.AddRange(insertions);
                }
            }

            return workUnits;
        }

        IReadOnlyList<IWorkUnit> CreateInsertions(Project project, INamedTypeSymbol prismApplicationSymbol, string viewModelMetaType, string viewMetaType)
        {
            var classDeclaration = prismApplicationSymbol.DeclaringSyntaxReferences.GetNonAutogeneratedSyntax() as ClassDeclarationSyntax;

            if (classDeclaration == null)
            {
                return Array.Empty<IWorkUnit>();
            }

            var workUnits = new List<IWorkUnit>();

            var registerTypes = classDeclaration.Members.OfType<MethodDeclarationSyntax>().FirstOrDefault(m => m.Identifier.Text == "RegisterTypes");

            if (registerTypes != null
                && registerTypes.ParameterList.Parameters.Count == 1)
            {
                var host = registerTypes.Body;
                var container = registerTypes.ParameterList.Parameters.FirstOrDefault();

                ViewModelPropertySnippet.SetArgumentValue(viewModelTypeArgument, viewModelMetaType);
                ViewModelPropertySnippet.SetArgumentValue(viewTypeArgument, viewMetaType);
                ViewModelPropertySnippet.SetArgumentValue(containerRegistryNameArgument, container.Identifier.Text);

                var insertion = ViewModelPropertySnippet.AsStatement();

                workUnits.Add(new InsertSyntaxNodesWorkUnit()
                {
                    Project = project,
                    HostNode = registerTypes,
                    SyntaxNodes = new List<SyntaxNode>()
                    {
                        insertion,
                    }
                });
            }

            return workUnits;
        }

        public override bool IsAvailable(ProjectIdentifier projectIdentifier)
        {
            return GetImplementationsOfPrismApplication(projectIdentifier).Any();
        }

        IEnumerable<INamedTypeSymbol> GetImplementationsOfPrismApplication(ProjectIdentifier projectIdentifier)
        {
            var project = ProjectService.GetProject(projectIdentifier);

            if (project == null)
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            if (!project.TryGetCompilation(out var compilation))
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            const string prismApplicationMetaName = "Prism.PrismApplicationBase";

            var prismApplicationType = compilation.GetTypeByMetadataName(prismApplicationMetaName);

            if (prismApplicationType == null)
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            var implementations = SymbolFinder.FindDerivedClassesAsync(prismApplicationType, project.Solution).Result.ToList();

            if (!implementations.Any())
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            return implementations.OfType<INamedTypeSymbol>()
                                   .Where(i => i.ContainingAssembly.Equals(compilation.Assembly))
                                  .Where(i => i.DeclaringSyntaxReferences.Any());
        }
    }
}