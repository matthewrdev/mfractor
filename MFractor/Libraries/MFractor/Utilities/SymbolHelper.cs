using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using MFractor.Utilities.SymbolVisitors;
using MFractor.Utilities.SyntaxVisitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MFractor.Utilities
{
    /// <summary>
    /// A helper class for working with symbols in Rolsyn.
    /// </summary>
    public static class SymbolHelper
    {
        public static bool HasAssemblyReference(this Project project, string assemblyName)
        {
            if (project is null)
            {
                throw new ArgumentNullException(nameof(project));
            }

            if (string.IsNullOrEmpty(assemblyName))
            {
                throw new ArgumentException("message", nameof(assemblyName));
            }

            if (!project.TryGetCompilation(out var compilation))
            {
                return false;
            }

            return compilation.HasAssembly(assemblyName);
        }

        /// <summary>
        /// Locate the project that owns the provided <paramref name="symbol"/>. 
        /// <para/>
        /// Returns null if this symbol isn't located in any projects in the current solution. For example, if the symbol originated from an assembly reference.
        /// </summary>
        public static Project GetProjectForSymbol(Solution solution, ISymbol symbol)
        {
            if (solution is null || symbol is null)
            {
                return default;
            }

            return solution.Projects.FirstOrDefault(p => p.AssemblyName == symbol.ContainingAssembly.Name);
        }

        public static IEnumerable<INamedTypeSymbol> GetDeclaredDerivedTypes(Project project, string fullyQualifiedMetaType)
        {
            if (project == null || string.IsNullOrEmpty(fullyQualifiedMetaType))
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            if (!project.TryGetCompilation(out var compilation))
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            var type = compilation.GetTypeByMetadataName(fullyQualifiedMetaType);

            return GetDeclaredDerivedTypes(compilation, type);
        }

        public static IEnumerable<INamedTypeSymbol> GetDeclaredDerivedTypes(Project project, INamedTypeSymbol namedType)
        {
            if (project == null || namedType == null)
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            if (!project.TryGetCompilation(out var compilation))
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            return GetDeclaredDerivedTypes(compilation, namedType);
        }

        public static IEnumerable<INamedTypeSymbol> GetDeclaredDerivedTypes(Compilation compilation, string fullyQualifiedMetaType)
        {
            if (compilation == null || string.IsNullOrEmpty(fullyQualifiedMetaType))
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            var visitor = new NamedTypeChildSymbolVisitor();
            visitor.NamedType = fullyQualifiedMetaType;

            var assembly = compilation.Assembly;

            var result = new List<INamedTypeSymbol>();

            void matchFound(INamedTypeSymbol match)
            {
                result.Add(match);
            }

            visitor.OnMatchFound = matchFound;

            foreach (var module in assembly.Modules)
            {
                visitor.VisitModule(module);
            }

            return result;
        }

        public static IEnumerable<INamedTypeSymbol> GetDeclaredDerivedTypes(Compilation compilation, INamedTypeSymbol namedType)
        {
            if (compilation == null || namedType == null)
            {
                return Enumerable.Empty<INamedTypeSymbol>();
            }

            return GetDeclaredDerivedTypes(compilation, namedType.ToString());
        }

        public static bool TryGetMemberLocation(ISymbol member, out string filePath, out Microsoft.CodeAnalysis.Text.TextSpan textSpan)
        {
            filePath = string.Empty;
            textSpan = Microsoft.CodeAnalysis.Text.TextSpan.FromBounds(0, 0);

            if (!IsNamedTypeMember(member))
            {
                return false;
            }

            var memberDeclarationSyntax = member.DeclaringSyntaxReferences.GetNonAutogeneratedSyntax() as MemberDeclarationSyntax;
            if (memberDeclarationSyntax is null)
            {
                return false;
            }

            filePath = memberDeclarationSyntax.SyntaxTree.FilePath;

            if (memberDeclarationSyntax is FieldDeclarationSyntax field)
            {
                textSpan = field.Declaration.Span;
            }
            else if (memberDeclarationSyntax is MethodDeclarationSyntax method)
            {
                textSpan = method.Identifier.Span;

            }
            else if (memberDeclarationSyntax is PropertyDeclarationSyntax property)
            {
                textSpan = property.Identifier.Span;

            }
            else if (memberDeclarationSyntax is EventDeclarationSyntax @event)
            {
                textSpan = @event.Identifier.Span;
            }
            else
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Given a <paramref name="member"/>, get the type that contains it.
        /// </summary>
        public static INamedTypeSymbol GetMemberContainingType(ISymbol member)
        {
            if (member is IMethodSymbol methodSymbol)
            {
                return methodSymbol.ContainingType;
            }
            else if (member is IEventSymbol eventSymbol)
            {
                return eventSymbol.ContainingType;
            }
            else if (member is IPropertySymbol propertySymbol)
            {
                return propertySymbol.ContainingType;
            }
            else if (member is IFieldSymbol fieldSymbol)
            {
                return fieldSymbol.ContainingType;
            }

            return null;
        }

        /// <summary>
        /// Given a <paramref name="member"/>, get the type that contains it.
        /// </summary>
        public static bool IsNamedTypeMember(ISymbol member)
        {
            if (member is IMethodSymbol methodSymbol
                || member is IEventSymbol eventSymbol
                || member is IPropertySymbol propertySymbol
                || member is IFieldSymbol fieldSymbol)
            {
                return true;
            }

            return false;
        }

        public static bool ExplodeTypeName(string qualifiedTypeName, out string @namespace, out string typeName)
        {
            typeName = string.Empty;
            @namespace = string.Empty;

            if (string.IsNullOrEmpty(qualifiedTypeName))
            {
                return false;
            }

            var parts = qualifiedTypeName.Split('.').ToList();
            typeName = parts.Last();

            @namespace = parts.Count > 1 ? string.Join(".", parts.GetRange(0, parts.Count - 1)) : string.Empty;

            return true;
        }

        /// <summary>
        /// Get all assemblies available for the <paramref name="project"/>.
        /// </summary>
        public static IEnumerable<IAssemblySymbol> GetAllAvailableAssemblySymbols(Project project)
        {
            var assemblies = new List<IAssemblySymbol>();

            if (project.TryGetCompilation(out var projectCompilation))
            {
                assemblies.Add(projectCompilation.Assembly);

                foreach (var md in project.MetadataReferences)
                {
                    var assembly = projectCompilation.GetAssemblyOrModuleSymbol(md) as IAssemblySymbol;

                    if (assembly != null)
                    {
                        assemblies.Add(assembly);
                    }
                }
            }

            foreach (var reference in project.ProjectReferences)
            {
                var projectReference = project.Solution.GetProject(reference.ProjectId);

                if (projectReference.TryGetCompilation(out var referenceCompilation))
                {
                    assemblies.Add(referenceCompilation.Assembly);
                }
            }
            return assemblies;
        }

        /// <summary>
        /// Is the provided <paramref name="type"/> a primitive value type?
        /// </summary>
        public static bool IsPrimitiveValueType(ITypeSymbol type)
        {
            return IsPrimitiveValueType(type.SpecialType);
        }

        /// <summary>
        /// Is the provided <paramref name="specialType"/> a primitive value type?
        /// </summary>
        /// <returns><c>true</c>, if primitive value type was ised, <c>false</c> otherwise.</returns>
        /// <param name="specialType">Type.</param>
        public static bool IsPrimitiveValueType(SpecialType specialType)
        {
            switch (specialType)
            {
                case SpecialType.System_Boolean:
                case SpecialType.System_Char:
                case SpecialType.System_SByte:
                case SpecialType.System_Byte:
                case SpecialType.System_Int16:
                case SpecialType.System_UInt16:
                case SpecialType.System_Int32:
                case SpecialType.System_UInt32:
                case SpecialType.System_Int64:
                case SpecialType.System_UInt64:
                case SpecialType.System_Decimal:
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                case SpecialType.System_DateTime:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Can the provided <paramref name="value"/> be parsed as the <paramref name="specialType"/>?
        /// </summary>
        public static bool CanParseAsPrimitiveValueType(string value, SpecialType specialType)
        {
            switch (specialType)
            {
                case SpecialType.System_Boolean:
                    {
                        return bool.TryParse(value, out _);
                    }
                case SpecialType.System_Char:
                    {
                        return char.TryParse(value, out _);
                    }
                case SpecialType.System_SByte:
                    {
                        return sbyte.TryParse(value, out _);
                    }
                case SpecialType.System_Byte:
                    {
                        return byte.TryParse(value, out _);
                    }
                case SpecialType.System_Int16:
                    {
                        return short.TryParse(value, out _);
                    }
                case SpecialType.System_UInt16:
                    {
                        return ushort.TryParse(value, out _);
                    }
                case SpecialType.System_Int32:
                    {
                        return int.TryParse(value, out _);
                    }
                case SpecialType.System_UInt32:
                    {
                        return uint.TryParse(value, out _);
                    }
                case SpecialType.System_Int64:
                    {
                        return long.TryParse(value, out _);
                    }
                case SpecialType.System_UInt64:
                    {
                        return ulong.TryParse(value, out _);
                    }
                case SpecialType.System_Decimal:
                    {
                        return decimal.TryParse(value, out _);
                    }
                case SpecialType.System_Single:
                    {
                        return float.TryParse(value, out _);
                    }
                case SpecialType.System_Double:
                    {
                        return double.TryParse(value, out _);
                    }
                case SpecialType.System_DateTime:
                    {
                        return DateTime.TryParse(value, out _);
                    }
                default:
                    return true;
            }
        }

        public static INamedTypeSymbol ResolveSymbolInCompilation(string symbolName, Compilation compilation)
        {
            if (compilation == null)
            {
                return null;
            }

            var classType = symbolName;
            if (symbolName.Contains("."))
            {
                var components = symbolName.Split('.');
                if (components.Length > 0)
                {
                    classType = components[0];
                }
            }

            var vistor = new FindNamedTypeVisitor(classType);

            // Inspect the current compilation module first to try for a local resolve...
            vistor.VisitModule(compilation.SourceModule);

            if (vistor.MatchedSymbol != null)
            {
                return vistor.MatchedSymbol;
            }
            else
            {
                foreach (var r in compilation.References)
                {
                    var assemblySymbol = compilation.GetAssemblyOrModuleSymbol(r) as IAssemblySymbol;
                    if (assemblySymbol != null)
                    {
                        foreach (var m in assemblySymbol.Modules)
                        {
                            vistor.VisitModule(m);

                            if (vistor.MatchedSymbol != null)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            var matchedSymbol = vistor.MatchedSymbol;
            return matchedSymbol;
        }

        public static INamespaceSymbol ResolveNamespaceSymbol(string namespaceName,
                                                              IAssemblySymbol assembly,
                                                              CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(namespaceName) || assembly is null)
            {
                return null;
            }

            INamespaceSymbol matchedSymbol = null;

            var vistor = new NamespaceVisitor(namespaceName, token);

            try
            {
                foreach (var m in assembly.Modules)
                {
                    vistor.VisitModule(m);

                    if (vistor.MatchedSymbol != null)
                    {
                        matchedSymbol = vistor.MatchedSymbol;
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }

            return matchedSymbol;
        }

        /// <summary>
        /// Does the <paramref name="compilation"/> reference the <paramref name="assemblyName"/>.
        /// </summary>
        public static bool HasAssembly(this Compilation compilation, string assemblyName, CancellationToken token = default)
        {
            return compilation.ResolveAssembly(assemblyName, token) != null;
        }

        /// <summary>
        /// Find the assembly named <paramref name="assemblyName"/> in the provided <paramref name="compilation"/>.
        /// </summary>
        public static IAssemblySymbol ResolveAssembly(this Compilation compilation, string assemblyName, CancellationToken token = default)
        {
            if (compilation == null || string.IsNullOrEmpty(assemblyName))
            {
                return null;
            }

            IAssemblySymbol assembly = null;

            if (compilation.SourceModule.ContainingAssembly.Name == assemblyName)
            {
                assembly = compilation.SourceModule.ContainingAssembly;
            }
            else
            {
                foreach (var r in compilation.References)
                {
                    token.ThrowIfCancellationRequested();
                    var symbol = compilation.GetAssemblyOrModuleSymbol(r);
                    if (symbol is IAssemblySymbol temp)
                    {
                        if (temp.Name == assemblyName)
                        {
                            assembly = temp;
                            break;
                        }
                    }
                }
            }

            return assembly;
        }

        /// <summary>
        /// Find the assembly named <paramref name="assemblyName"/> in the provided <paramref name="compilation"/>.
        /// </summary>
        public static bool HasAssembly(this Compilation compilation, Func<string, bool> predicate, CancellationToken token = default)
        {
            if (compilation == null || predicate == null)
            {
                return false;
            }

            if (predicate(compilation.SourceModule.ContainingAssembly.Name))
            {
                return true;
            }

            foreach (var r in compilation.References)
            {
                token.ThrowIfCancellationRequested();
                var symbol = compilation.GetAssemblyOrModuleSymbol(r);
                if (symbol is IAssemblySymbol temp
                    && predicate(temp.Name))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Find the provided <paramref name="symbolName"/> in
        /// </summary>
        public static INamedTypeSymbol ResolveNearlyNameSymbolInAssembly(string symbolName, IAssemblySymbol assembly, bool fuzzySearch, CancellationToken token = default)
        {
            if (assembly == null)
            {
                return null;
            }

            var vistor = new FindNamedTypeVisitor(symbolName, token);

            vistor.FuzzySearch = fuzzySearch;
            // Inspect the current compilation module first to try for a local resolve...
            vistor.VisitAssembly(assembly);

            var matchedSymbol = vistor.MatchedSymbol;
            return matchedSymbol;
        }

        /// <summary>
        /// Find a member named <paramref name="memberName"/> in the <paramref name="targetSymbol"/>.
        /// </summary>
        public static ISymbol FindMemberSymbolByName(string typeName, string memberName, Compilation compilation, CancellationToken token = default)
        {
            var typeSymbol = compilation.GetTypeByMetadataName(typeName);

            return FindMemberSymbolByName(typeSymbol, memberName, token);
        }

        /// <summary>
        /// Find a member named <paramref name="memberName"/> in the <paramref name="targetSymbol"/>.
        /// </summary>
        public static ISymbol FindMemberSymbolByName(ITypeSymbol targetSymbol, string memberName, CancellationToken token = default)
        {
            if (targetSymbol == null)
            {
                return null;
            }

            var symbol = targetSymbol.GetMembers(memberName).FirstOrDefault();

            if (symbol == null)
            {
                var baseType = targetSymbol.BaseType;

                while (baseType != null)
                {

                    token.ThrowIfCancellationRequested();

                    // Resolve the base type symbols.

                    symbol = baseType.GetMembers(memberName).FirstOrDefault();

                    if (symbol == null)
                    {
                        baseType = baseType.BaseType;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            return symbol;
        }

        /// <summary>
        /// Find a symbol named <paramref name="memberName"/> in the <paramref name="targetSymbol"/> that is a <typeparamref name="TSymbol"/>.
        /// </summary>
        public static TSymbol FindMemberSymbolByName<TSymbol>(ITypeSymbol targetSymbol, string memberName, CancellationToken token = default(CancellationToken)) where TSymbol : class, ISymbol
        {
            if (targetSymbol == null)
            {
                return null;
            }

            var symbol = targetSymbol.GetMembers(memberName).OfType<TSymbol>().FirstOrDefault();

            if (symbol == null)
            {
                var baseType = targetSymbol.BaseType;

                while (baseType != null)
                {

                    token.ThrowIfCancellationRequested();

                    // Resolve the base type symbols.

                    symbol = baseType.GetMembers(memberName).OfType<TSymbol>().FirstOrDefault();

                    if (symbol == null)
                    {
                        baseType = baseType.BaseType;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            return symbol;
        }

        /// <summary>
        /// Get all member symbols for the <paramref name="targetSymbol"/> of that are a <typeparamref name="TSymbol"/>.
        /// </summary>
        public static IEnumerable<TSymbol> GetAllMemberSymbols<TSymbol>(ITypeSymbol targetSymbol, CancellationToken token = default) where TSymbol : class, ISymbol
        {
            if (targetSymbol == null)
            {
                return Enumerable.Empty<TSymbol>();
            }

            var symbols = new List<TSymbol>();

            symbols.AddRange(targetSymbol.GetMembers().OfType<TSymbol>());

            var baseType = targetSymbol.BaseType;

            while (baseType != null)
            {

                token.ThrowIfCancellationRequested();

                // Resolve the base type symbols.

                symbols.AddRange(baseType.GetMembers().OfType<TSymbol>());
                baseType = baseType.BaseType;
            }

            return symbols.Where(s => s != null);
        }

        /// <summary>
        /// Is the <paramref name="right"/> type assignable to <paramref name="left"/>?
        /// </summary>
        public static bool IsAssignable(ITypeSymbol left, ITypeSymbol right)
        {
            if (left == null || right == null)
            {
                return false;
            }

            if (left.IsValueType
                && right.IsValueType)
            {
                return left.SpecialType == right.SpecialType;
            }

            return DerivesFrom(left, right);
        }

        /// <summary>
        /// Checks if there is a type mismatch between <paramref name="current"/> and <paramref name="expected"/>.
        /// <para/>
        /// Providing null for <paramref name="current"/> or <paramref name="expected"/> will return true.
        /// </summary>
        public static bool IsTypeMismatch(ITypeSymbol current, ITypeSymbol expected)
        {
            if (current == null || expected == null)
            {
                return true;
            }

            if (current.IsValueType
                && expected.IsValueType)
            {
                if (IsNumber(current) && IsNumber(expected))
                {
                    return false;
                }

                return current.SpecialType != expected.SpecialType;
            }

            return !DerivesFrom(current, expected);
        }

        public static bool IsFloatingPoint(ITypeSymbol type)
        {
            if (type is null)
            {
                return false;
            }

            return type.SpecialType == SpecialType.System_Double
                   || type.SpecialType == SpecialType.System_Decimal;
        }


        public static bool IsInteger(ITypeSymbol type)
        {
            if (type is null)
            {
                return false;
            }

            return type.SpecialType == SpecialType.System_UInt16
                   || type.SpecialType == SpecialType.System_UInt32
                   || type.SpecialType == SpecialType.System_UInt64
                   || type.SpecialType == SpecialType.System_Int16
                   || type.SpecialType == SpecialType.System_Int32
                   || type.SpecialType == SpecialType.System_Int64;
        }

        public static bool IsNumber(ITypeSymbol type)
        {
            if (type is null)
            {
                return false;
            }

            return IsInteger(type) || IsFloatingPoint(type);
        }

        /// <summary>
        /// Checks if <paramref name="current"/> derives from <paramref name="expected"/>
        /// <para/>
        /// Providing null for <paramref name="current"/> or <paramref name="expected"/> will result in false.
        /// </summary>
        public static bool DerivesFrom(ITypeSymbol current, ITypeSymbol expected)
        {
            if (current == null
                || expected == null)
            {
                return false;
            }

            if (current.Equals(expected))
            {
                return true;
            }

            if (expected.SpecialType == SpecialType.System_Object
                && current.IsReferenceType)
            {
                return true;
            }

            if (expected.TypeKind == TypeKind.Interface)
            {
                // Check if it implements the interface...
                var interfaceSymbol = current.AllInterfaces.FirstOrDefault(i => i.MetadataName == expected.MetadataName);

                if (interfaceSymbol != null)
                {
                    return true;
                }
            }

            return DerivesFrom(current, expected.ToString());
        }

        /// <summary>
        /// Checks if the <paramref name="current"/> derives from <paramref name="expectedMetaTypeName"/>
        /// <para/>
        /// Provide null for <paramref name="current"/> will result in a false
        /// </summary>
        public static bool DerivesFrom(ITypeSymbol current, string expectedMetaTypeName)
        {
            if (current == null)
            {
                return false;
            }

            var derives = false;
            var type = current;
            while (type != null)
            {
                var full = type.ToDisplayString();
                var metaTypeName = type.ToString();
                if (metaTypeName == expectedMetaTypeName)
                {
                    derives = true;
                    break;
                }

                // Check if it implements the interface...
                var interfaceSymbol = type.Interfaces.FirstOrDefault(i => i.ToString() == expectedMetaTypeName);

                if (interfaceSymbol != null)
                {
                    derives = true;
                    break;
                }

                type = type.BaseType;
            }

            return derives;
        }

        /// <summary>
        /// Gets the return type of the provided symbol.
        /// <para/>
        /// It is safe to provide a null value for <paramref name="symbol"/>.
        /// </summary>
        public static ITypeSymbol ResolveMemberReturnType(ISymbol symbol)
        {
            ITypeSymbol result = null;

            if (symbol is IFieldSymbol field)
            {
                result = field.Type;
            }
            else if (symbol is IPropertySymbol property)
            {
                result = property.Type;
            }
            else if (symbol is IMethodSymbol method)
            {
                result = method.ReturnType;
            }

            return result;
        }

        /// <summary>
        /// Resolves the symbol of type <typeparamref name="TSymbol"/> that is most closely named <paramref name="name"/> from the provided <paramref name="symbols"/>.
        /// </summary>
        public static TSymbol ResolveNearestSymbol<TSymbol>(string name, List<TSymbol> symbols) where TSymbol : class, ISymbol
        {
            if (symbols == null || !symbols.Any())
            {
                return default;
            }

            TSymbol nearestMatch = null;

            var nearestMatchDistance = int.MaxValue;
            foreach (var s in symbols)
            {
                var distance = LevenshteinDistanceHelper.Compute(s.Name, name);
                if (distance < nearestMatchDistance)
                {
                    nearestMatch = s;
                    nearestMatchDistance = distance;
                }
            }

            return nearestMatchDistance < 3 ? nearestMatch : null;
        }

        public static ISymbol ResolveNearestNamedMember(ITypeSymbol typeSymbol, string name, Func<ISymbol, bool> memberIsValidFunc = null)
        {
            var members = new List<ISymbol>();

            var evaluator = memberIsValidFunc;
            if (evaluator == null)
            {
                evaluator = m => m is IPropertySymbol || m is IMethodSymbol || m is IFieldSymbol || m is IEventSymbol;
            }

            var elementType = typeSymbol;
            while (elementType != null)
            {
                members.AddRange(elementType.GetMembers().Where(evaluator).ToList());
                elementType = elementType.BaseType;
            }

            ISymbol nearestMatch = null;

            var nearestMatchDistance = int.MaxValue;
            foreach (var m in members)
            {
                var distance = LevenshteinDistanceHelper.Compute(m.Name, name);
                if (distance < nearestMatchDistance)
                {
                    nearestMatch = m;
                    nearestMatchDistance = distance;
                }
            }

            return nearestMatchDistance < 3 ? nearestMatch : null;
        }

        public static IPropertySymbol ResolveNearestNamedProperty(ITypeSymbol typeSymbol, string name)
        {
            return ResolveNearestNamedMember(typeSymbol, name, (m) => m is IPropertySymbol) as IPropertySymbol;
        }


        public static SyntaxNode GetNonAutogeneratedSyntax(this INamedTypeSymbol namedTypeSymbol)
        {
            if (namedTypeSymbol == null)
            {
                return null;
            }

            return namedTypeSymbol.DeclaringSyntaxReferences.GetNonAutogeneratedSyntax();
        }

        public static SyntaxNode GetNonAutogeneratedSyntax(this ImmutableArray<SyntaxReference> syntaxReferences)
        {
            return syntaxReferences.FirstOrDefault(s => IsNonAutoGeneratedSyntax(s.SyntaxTree))
                                   ?.GetSyntax();
        }

        public static IEnumerable<SyntaxNode> GetAllNonAutogeneratedSyntax(this ImmutableArray<SyntaxReference> syntaxReferences)
        {
            return syntaxReferences.Where(s => IsNonAutoGeneratedSyntax(s.SyntaxTree))
                                   .Select(s => s.GetSyntax());
        }

        public static bool IsNonAutoGeneratedSyntax(SyntaxTree syntaxTree)
        {
            if (!syntaxTree.FilePath.EndsWith(".cs"))
            {
                return false;
            }


            var isAutogenerated = IsAutoGeneratedFilePath(syntaxTree?.FilePath);

            return !isAutogenerated;
        }

        public static bool IsAutoGeneratedSyntax(SyntaxTree syntaxTree)
        {
            return IsAutoGeneratedFilePath(syntaxTree?.FilePath);
        }

        public static bool IsAutoGeneratedFilePath(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
            {
                return false;
            }

            if (filePath.EndsWith(".cs"))
            {
                var isAutogenerated = filePath.EndsWith(".g.cs", System.StringComparison.OrdinalIgnoreCase)
                                      || filePath.EndsWith(".g.i.cs", System.StringComparison.OrdinalIgnoreCase);

                return isAutogenerated;
            }

            return false;
        }
    }
}
