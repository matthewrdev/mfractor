using System;using System.Collections.Generic;using System.ComponentModel.Composition.Hosting;using System.Linq;using MFractor.IOC;using MFractor.VS.Windows;
using Microsoft.VisualStudio.ComponentModelHost;using Microsoft.VisualStudio.Shell;[assembly: DeclareExportResolver(typeof(IdeExportResolver))]namespace MFractor.VS.Windows{    class IdeExportResolver : BaseExportResolver    {        readonly Lazy<IComponentModel> container = new Lazy<IComponentModel>(GetComponentModel);                public static IComponentModel GetComponentModel()        {            return (IComponentModel)Package.GetGlobalService(typeof(SComponentModel));        }        public IdeExportResolver()        {        }        protected ExportProvider ExportProvider => container.Value.DefaultExportProvider;        public override Lazy<T> GetExport<T>()        {            return ExportProvider.GetExport<T>();        }        public override Lazy<IEnumerable<T>> GetExports<T>()        {            return new Lazy<IEnumerable<T>>( () => ExportProvider.GetExportedValues<T>());        }        public override T GetExportedValue<T>()        {            return ExportProvider.GetExportedValue<T>();        }        public override IEnumerable<T> GetExportedValues<T>()        {            var values = ExportProvider.GetExportedValues<T>().ToList();            return values;        }        public override object GetExportedValue(Type type)        {            var provider = ExportProvider;            // get a reference to the GetExportedValue<T> method            var methodInfo = provider.GetType()                                     .GetMethods()                                     .First(d => d.Name == "GetExportedValue" && d.GetParameters().Length == 0);            // create an array of the generic types that the GetExportedValue<T> method expects            var genericTypeArray = new Type[] { type };            // add the generic types to the method            methodInfo = methodInfo.MakeGenericMethod(genericTypeArray);            // invoke GetExportedValue<type>()            return methodInfo.Invoke(provider, null);        }        public override IEnumerable<object> GetExportedValues(Type type)        {            var provider = ExportProvider;            // get a reference to the GetExportedValue<T> method            var methodInfo = provider.GetType()                                     .GetMethods()                                     .First(d => d.Name == "GetExportedValues" && d.GetParameters().Length == 0);            // create an array of the generic types that the GetExportedValues<T> method expects            var genericTypeArray = new Type[] { type };            // add the generic types to the method            methodInfo = methodInfo.MakeGenericMethod(genericTypeArray);            // invoke GetExportedValue<type>()            return (IEnumerable<object>)methodInfo.Invoke(provider, null);        }    }}